using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DomainHelpers.Generator;

[Generator(LanguageNames.CSharp)]
public partial class PrefixedUlidGenerator : IIncrementalGenerator {
    const string _prefixedUlidAttributeClass = """
        namespace DomainHelpers;
        
        using System;
        
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
        public class PrefixedUlidAttribute : Attribute {
            public string Prefix { get; }
        
            public char Separator { get; }
        
            public PrefixedUlidAttribute(string prefix, char separator = '_') { 
                Prefix = prefix;
                Separator = separator;
            }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(static context => {
            context.AddSource("PrefixedUlidAttribute.cs", _prefixedUlidAttributeClass);
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "DomainHelpers.PrefixedUlidAttribute",
            static (node, token) => true,
            static (context, token) => context
        );

        // 出力コード部分はちょっとごちゃつくので別メソッドに隔離
        context.RegisterSourceOutput(source, Emit);
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source) {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        // グローバルネームスペース対応
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";

        var (prefix, separator) = typeSymbol.GetAttributes()
            .Where(x => x.AttributeClass?.Name is "PrefixedUlidAttribute")
            .Select(x => (
                (string?)x.ConstructorArguments[0].Value,
                (char?)x.ConstructorArguments[1].Value
             ))
            .FirstOrDefault();

        var code = $$"""
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS8600
            #pragma warning disable CS8601
            #pragma warning disable CS8602
            #pragma warning disable CS8603
            #pragma warning disable CS8604

            {{ns}}

            partial record {{typeSymbol.Name}} : DomainHelpers.Domain.Indentifier.PrefixedUlid {
                public const int TotalLength = {{(prefix?.Length ?? 0) + 1 + 26}};
                public const string Prefix = "{{prefix}}";
                public const string Separator = "{{separator}}";

                public static {{typeSymbol.Name}} Default {get; } = default!;

                public static {{typeSymbol.Name}} Empty {get; } = Parse($"{{prefix}}{{separator}}{default(DomainHelpers.Commons.Primitives.Ulid)}");

                public override string PrefixWithSeparator => "{{prefix}}{{separator}}";
 
                public static {{typeSymbol.Name}} CreateNew() => DomainHelpers.Domain.Indentifier.PrefixedUlid.NewPrefixedUlid<{{typeSymbol.Name}}>();

                public static {{typeSymbol.Name}} Parse(string id) {
                    return DomainHelpers.Domain.Indentifier.PrefixedUlid.Parse<{{typeSymbol.Name}}>(id);
                }

                public static implicit operator string({{typeSymbol.Name}} id) => id.ToString();

                public static implicit operator {{typeSymbol.Name}}(string id) => Parse(id);
            }
            """;


        // 出力ファイル名として使ためのエスケープ
        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        context.AddSource($"{fullType}.g.cs", code);
    }
}

